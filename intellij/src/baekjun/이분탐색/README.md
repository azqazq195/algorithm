## 이분 탐색이란?

- **정의**: 이분 탐색은 정렬된 배열에서 특정 값을 찾는 효율적인 방법입니다. 탐색 범위를 절반으로 줄여가며 값을 찾습니다.
- **시간 복잡도**: O(log n). 각 단계에서 탐색 범위를 절반으로 줄이므로 매우 빠릅니다.
- **동작 원리**:
    1. 배열의 중간값을 구하고, 그 값이 찾는 값과 비교됩니다.
    2. 찾는 값이 중간값보다 작으면, 왼쪽 절반에서 탐색을 계속합니다.
    3. 찾는 값이 중간값보다 크면, 오른쪽 절반에서 탐색을 계속합니다.
    4. 이를 반복하여 값을 찾거나, 범위가 없어지면 값을 찾지 못한 것으로 결론내립니다.

## 기본 구조


```java
int min = 0; // or 1
int max = Int.MAX_VALUE;

while (min <= max) { // 1
    int mid = min + (max - min) / 2; // 2

    // 로직
  
    if (some >= m) { // 3
        min = mid + 1;
    } else {
        max = mid - 1;
    }
}
```


## 주의 사항


### `while (min <= max)`

- `min <= max` :
    - 마지막 중간값까지 고려
    - 정확한 값을 찾거나, 최적의 값을 반환해야 할 때 사용
- `min < max` :
    - 범위 내에서 조건을 만족하는 값 중 하나만 필요할 때 사용

### `int mid = min + (max - min) / 2`

- **`min + (max - min) / 2`**:
    - **오버플로우 방지**를 위해 사용하는 방식입니다.
    - `min + max`를 계산하는 경우, 오버플로우가 발생할 수 있음
        - 변수들이 다 int 형인 경우, min & max 가 int.MAX_VALUE 라면? 오버플로우 발생
    - `(max - min)`을 먼저 계산해 범위 내에서 중간값 계산
- **`(min + max) >> 1`**:
    - `>> 1` 2로 나누는 연산으로, 빠른 계산이 가능합니다.
    - `min + max` 에서 오버플로우가 발생할 수 있음

### `if (some >= m)` vs `if (some > m)`

- **`if (some >= m)`**:
    - `some` 값이 `m`과 같거나 클 때 조건을 만족합니다.
    - 즉, `some == m`일 때도 조건을 충족하여 `min`을 증가시키는 경우에 사용합니다.
    - **추천 상황**: **정확히 `m`개 이상의 값**이 필요한 상황에 사용합니다.
- **`if (some > m)`**:
    - `some` 값이 **`m`보다 클 때만** 조건을 만족합니다.
    - `some == m`일 경우에는 조건을 충족하지 않으므로, `m` 이상의 값만 고려하는 경우입니다.
    - **추천 상황**: `m`보다 **엄격하게 큰 값**을 원할 때 사용합니다.
